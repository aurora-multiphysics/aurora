<!DOCTYPE html><head><meta charset="UTF-8"><title>ExplicitTimeIntegrator | Aurora App</title><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/katex_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script><script type="text/javascript" src="../../contrib/katex/katex.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="https://aurora-multiphysics.github.io/aurora/" class="left moose-logo hide-on-med-and-down">Aurora App</a><a href="https://github.com/aurora-multiphysics/aurora" class="right"><img src="../../media/framework/github-logo.png" class="github-mark"></img><img src="../../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"></ul><a href="#" class="sidenav-trigger" data-target="f71c1adf-743e-442b-8b20-9a23235eec87"><i class="material-icons">menu</i></a><ul class="sidenav" id="f71c1adf-743e-442b-8b20-9a23235eec87"></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input type_="text" onkeyup="mooseSearch()" placeholder="https://aurora-multiphysics.github.io/aurora/" id="moose-search-box"></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="col hide-on-med-and-down l12"><nav class="breadcrumb-nav"><div class="nav-wrapper"><a href=".." class="breadcrumb">source</a><span class="breadcrumb">timeintegrators</span><a href="#" class="breadcrumb">ExplicitTimeIntegrator</a></div></nav></div></div><div class="row"><div class="moose-content col s12 m12 l10"><section id="fc432c64-2fc3-4fc3-a8c4-3ae61302df1d" data-section-level="1" data-section-text="ExplicitTimeIntegrator"><h1 id="explicittimeintegrator">ExplicitTimeIntegrator</h1><section class="scrollspy" id="bd11576a-6ab3-4c7f-870b-77184c06ab9d" data-section-level="2" data-section-text="Description"><h2 id="description">Description</h2><p><code>ExplicitTimeIntegrator</code> is a base class for explicit time integrators that are implemented without performing any nonlinear solve, which reduces runtime. Unlike explicit time integrators that are not derived from this class, it is not necessary to set <code>implicit</code> to <code>false</code> for all of the non-time residual objects.</p></section><section class="scrollspy" id="87c8d255-602f-4ecf-9e72-ee55bc2ccca9" data-section-level="2" data-section-text="Methods of Solution"><h2 id="methods-of-solution">Methods of Solution</h2><p>Time integrators deriving from this class have three solve options, provided via the <code>solve_type</code> parameter:</p><ul class="browser-default"><li><p><code>consistent</code>: (the default) A full mass matrix is built and used in a linear solve for the update </p></li><li><p><code>lumped</code>: A &quot;lumped&quot; mass matrix is built, inverted, and applied to the RHS, which is faster but can possibly be less accurate. </p></li><li><p><code>lump_preconditioned</code>: The inversion of the &quot;lumped&quot; mass matrix is used to precondition the <code>consistent</code> solve.</p></li></ul><p>All three methods are solved similarly: a linear solve is performed to obtain a solution update <span class="moose-katex-inline-equation" id="moose-equation-cd140d81-0ff5-4496-9475-1a768b5ccac9"><script>var element = document.getElementById("moose-equation-cd140d81-0ff5-4496-9475-1a768b5ccac9");katex.render("\\delta u", element, {displayMode:false,throwOnError:false});</script></span> that is added to the existing solution.</p><p>Below is some more explanation of each of these <code>solve_type</code> options:</p><section id="4055d7a8-9f18-47f5-a0e1-97cb65008d97" data-section-level="3" data-section-text="consistent"><h3><code>consistent</code></h3><p>The <code>consistent</code> option builds a full (&quot;consistent&quot;) &quot;mass matrix&quot; and uses it in a linear solve to get the update.  This is done by calling <code>FEProblem::computeJacobianTag()</code> and specifying the <code>TIME</code> tag which includes all of the <code>TimeKernel</code> derived Kernels and <code>NodalBC</code> derived BoundaryConditions to compute <span class="moose-katex-inline-equation" id="moose-equation-5f72a02b-8e4a-40cd-95a6-f383bc1b461f"><script>var element = document.getElementById("moose-equation-5f72a02b-8e4a-40cd-95a6-f383bc1b461f");katex.render("\\mathbf{M}", element, {displayMode:false,throwOnError:false});</script></span>:</p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">    _fe_problem.computeJacobianTag(
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#bfc4a132-17ed-491e-9ce8-29f0a7d9fa71">(../../../SoftwareDownloads/moose/framework/src/timeintegrators/ActuallyExplicitEuler.C)</a><p>A residual computation is also completed to use as the RHS (<span class="moose-katex-inline-equation" id="moose-equation-7fd8adc9-24c4-4e96-b8e3-819a407a689b"><script>var element = document.getElementById("moose-equation-7fd8adc9-24c4-4e96-b8e3-819a407a689b");katex.render("R", element, {displayMode:false,throwOnError:false});</script></span>):</p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">  _fe_problem.computeResidual(*_nonlinear_implicit_system-&gt;current_local_solution,
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#b923bf70-aa15-4388-8741-2b77c800afa6">(../../../SoftwareDownloads/moose/framework/src/timeintegrators/ActuallyExplicitEuler.C)</a><p>Finally, the following linear system is solved to obtain the solution update <span class="moose-katex-inline-equation" id="moose-equation-05b646c9-75e2-43e5-91a2-09fc65d1b0c3"><script>var element = document.getElementById("moose-equation-05b646c9-75e2-43e5-91a2-09fc65d1b0c3");katex.render("\\delta u", element, {displayMode:false,throwOnError:false});</script></span> using the default linear solver from libMesh (usually PETSc, including the application of any command-line parameters specified):</p><p><span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-71caba1b-90eb-4cbc-aed5-961f29c3c63b"></span><script>var element = document.getElementById("moose-equation-71caba1b-90eb-4cbc-aed5-961f29c3c63b");katex.render("\\mathbf{M} \\delta u = -R", element, {displayMode:true,throwOnError:false});</script></span></p></section><section id="e6119d3b-cd4b-42a4-b8f5-899fdc246014" data-section-level="3" data-section-text="lumped"><h3><code>lumped</code></h3><p>The <code>lumped</code> option creates a &quot;lumped&quot; mass matrix to use in the solve.  A lumped mass matrix is a diagonal matrix where the diagonal is the sum of all elements on the row from the original matrix. Here, to achieve the lumping, a matrix-vector product is performed between the consistent mass matrix and a vector of all ones.</p><p>The inverse of a diagonal matrix is simply the reciprocal of each diagonal entry. Then the matrix-vector product of the &quot;inverse&quot; lumped diagonal matrix is applied by simply doing a pointwise multiplication with the RHS.</p><p>Thus the <code>lumped</code> option does not actually solve a system of linear equations, allowing it be much faster. However, the lumping of the mass matrix may lead to unacceptable phase errors.</p></section><section id="5a3f098d-5893-460d-b552-7c3b325b8169" data-section-level="3" data-section-text="lump_preconditioned"><h3><code>lump_preconditioned</code></h3><p>This option is the combination of the other two options: the consistent mass matrix is used in the linear system, but the linear solve is preconditioned using the lumped mass matrix. This compromise retains the accuracy of the <code>consistent</code> option while benefiting from some of the speedup offered by the <code>lumped</code> option.</p><p>The lumped mass matrix preconditioner is applied with the class, <code>LumpedPreconditioner</code>:</p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">
#pragma once

// MOOSE includes
#include &quot;NonlinearSystem.h&quot;
#include &quot;FEProblem.h&quot;
#include &quot;PetscSupport.h&quot;

// libMesh includes
#include &quot;libmesh/sparse_matrix.h&quot;
#include &quot;libmesh/nonlinear_solver.h&quot;
#include &quot;libmesh/preconditioner.h&quot;

// Forward declarations
class LumpedPreconditioner;

/**
 * Class to that applies the lumped mass matrix preconditioner
 * in the ExplicitTimeIntegrator
 */
class LumpedPreconditioner : public Preconditioner&lt;Real&gt;
{
public:
  LumpedPreconditioner(const NumericVector&lt;Real&gt; &amp; diag_inverse)
    : Preconditioner(diag_inverse.comm()), _diag_inverse(diag_inverse)
  {
  }

  virtual void init() override
  {
    // No more initialization needed here
    _is_initialized = true;
  }

  virtual void apply(const NumericVector&lt;Real&gt; &amp; x, NumericVector&lt;Real&gt; &amp; y) override
  {
    y.pointwise_mult(_diag_inverse, x);
  }

protected:
  /// The inverse of the diagonal of the lumped matrix
  const NumericVector&lt;Real&gt; &amp; _diag_inverse;
};
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#d38ec6df-dcb0-4ba0-a290-89944d627e10">(../../../SoftwareDownloads/moose/framework/include/timeintegrators/LumpedPreconditioner.h)</a><p>This object simply applies the inverse of the diagonal, lumped mass-matrix as the preconditioner for the linear solve, which is very efficient. Note that when this option is applied you shouldn&#x27;t specify any other preconditioners using command-line syntax or they will override this option.</p></section></section><section class="scrollspy" id="f5e108d9-2ae2-4fd8-96d2-d35c86c1bdf7" data-section-level="2" data-section-text="Additional Details"><h2 id="additional-details">Additional Details</h2><p>Some notes on some of the implementation details of this class follow.</p><section id="f4421c3c-0d0c-427c-834a-d56d35faf6f8" data-section-level="3" data-section-text="Update Form"><h3 id="update-form">Update Form</h3><p>Note that even though we&#x27;re doing an explicit solve we are currently doing it in &quot;update form&quot; similar to a single step Newton solve.  This gives us good parity with the rest of MOOSE.  We may want to change this in the future to make better use of the fact that the mass-matrix can be constant for a wider class of problems if we remove <code>dt</code> from it.</p></section><section id="08ba7f94-d98d-4d1e-bd5e-1bec0490cd3f" data-section-level="3" data-section-text="_ones"><h3><code>_ones</code></h3><p>To get the sum of each row of the mass matrix for &quot;lumping&quot; purposes a vector consisting of all <code>1</code>s is used in a matrix-vector product:</p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">      mass_matrix.vector_mult(_mass_matrix_diag, *_ones);
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#e899e051-d59b-4354-9ec0-7fd3a2fb977c">(../../../SoftwareDownloads/moose/framework/src/timeintegrators/ExplicitTimeIntegrator.C)</a><p>This is actually the very same way <code>MatGetRowSum</code> is implemented in PETSc; however, doing it manually cuts down on vector creation/destruction and a few other book-keeping operations.</p><p>In the future this could be changed to use <code>MatGetRowSum</code> if a specialization for <code>MPI_Aij</code> format is created.</p></section><section id="1763a964-cd35-4c3a-ae0c-bc8c25cc78ff" data-section-level="3" data-section-text="Time"><h3 id="time">Time</h3><p>Time in an explicit solve must be handled carefully. When evaluating the weak form (the integral parts) of the residual, time needs to be set to be the &quot;old&quot; time (the time we are solving &quot;from&quot;):</p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">  _fe_problem.time() = _fe_problem.timeOld();
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#55c4fdb0-48ff-49d1-b91e-5020b4e49a72">(../../../SoftwareDownloads/moose/framework/src/timeintegrators/ActuallyExplicitEuler.C)</a><p>However, <code>DirichletBC</code> derived boundary conditions need to use the <em></em>final** time, since the strong constraints they represent use the final time and are not affected by the time integrator. To achieve this, time is reset to the <code>_current_time</code> after the weak form residual evaluation and before <code>NodalBC</code> boundary condition application, which makes <code>postResidual()</code> the correct place to reset time for this purpose:</p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">  _fe_problem.time() = _current_time;
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#ed867f14-2b43-429a-b418-d6fdc38c0b47">(../../../SoftwareDownloads/moose/framework/src/timeintegrators/ActuallyExplicitEuler.C)</a><p>After <code>postResidual()</code> the <code>NodalBC</code> BCs are applied with the time at the final time for the step.</p></section><section id="ab6a686f-81a3-4cea-91a9-3d8c179ebde8" data-section-level="3" data-section-text="meshChanged()"><h3><code>meshChanged()</code></h3><p>When the mesh changes the linear solver needs to be destroyed and recreated. This is done by simply building a new one and setting it up again.  This happens automatically just by &quot;overwriting&quot; the <code>std::unique_ptr</code> to the LinearSolver. </p></section></section></section><div class="moose-modal modal" id="bfc4a132-17ed-491e-9ce8-29f0a7d9fa71"><div class="modal-content"><h4>(../../../SoftwareDownloads/moose/framework/src/timeintegrators/ActuallyExplicitEuler.C)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

// MOOSE includes
#include &quot;ActuallyExplicitEuler.h&quot;
#include &quot;NonlinearSystem.h&quot;
#include &quot;FEProblem.h&quot;

// libMesh includes
#include &quot;libmesh/nonlinear_solver.h&quot;

registerMooseObject(&quot;MooseApp&quot;, ActuallyExplicitEuler);

defineLegacyParams(ActuallyExplicitEuler);

InputParameters
ActuallyExplicitEuler::validParams()
{
  InputParameters params = ExplicitTimeIntegrator::validParams();

  params.addClassDescription(
      &quot;Implementation of Explicit/Forward Euler without invoking any of the nonlinear solver&quot;);

  params.addParam&lt;bool&gt;(&quot;use_constant_mass&quot;,
                        false,
                        &quot;If set to true, will only compute the mass matrix in the first time step, &quot;
                        &quot;and keep using it throughout the simulation.&quot;);

  return params;
}

ActuallyExplicitEuler::ActuallyExplicitEuler(const InputParameters &amp; parameters)
  : ExplicitTimeIntegrator(parameters), _constant_mass(getParam&lt;bool&gt;(&quot;use_constant_mass&quot;))
{
}

void
ActuallyExplicitEuler::computeTimeDerivatives()
{
  if (!_sys.solutionUDot())
    mooseError(&quot;ActuallyExplicitEuler: Time derivative of solution (`u_dot`) is not stored. Please &quot;
               &quot;set uDotRequested() to true in FEProblemBase before requesting `u_dot`.&quot;);

  NumericVector&lt;Number&gt; &amp; u_dot = *_sys.solutionUDot();
  u_dot = *_solution;
  computeTimeDerivativeHelper(u_dot, _solution_old);
  u_dot.close();

  _du_dot_du = 1.0 / _dt;
}

void
ActuallyExplicitEuler::computeADTimeDerivatives(DualReal &amp; ad_u_dot, const dof_id_type &amp; dof) const
{
  computeTimeDerivativeHelper(ad_u_dot, _solution_old(dof));
}

void
ActuallyExplicitEuler::solve()
{
  // Reset iteration counts
  _n_nonlinear_iterations = 0;
  _n_linear_iterations = 0;

  _current_time = _fe_problem.time();

  // Set time to the time at which to evaluate the residual
  _fe_problem.time() = _fe_problem.timeOld();
  _nonlinear_implicit_system-&gt;update();

  // Compute the residual
  _explicit_residual.zero();
  _fe_problem.computeResidual(*_nonlinear_implicit_system-&gt;current_local_solution,
                              _explicit_residual);

  // Move the residual to the RHS
  _explicit_residual *= -1.0;

  // Compute the mass matrix
  auto &amp; mass_matrix = _nonlinear_implicit_system-&gt;get_system_matrix();
  if (!_constant_mass || (_constant_mass &amp;&amp; _t_step == 1))
    _fe_problem.computeJacobianTag(
        *_nonlinear_implicit_system-&gt;current_local_solution, mass_matrix, _Ke_time_tag);

  // Perform the linear solve
  bool converged = performExplicitSolve(mass_matrix);

  // Update the solution
  *_nonlinear_implicit_system-&gt;solution = _nl.solutionOld();
  *_nonlinear_implicit_system-&gt;solution += _solution_update;

  // Enforce contraints on the solution
  DofMap &amp; dof_map = _nonlinear_implicit_system-&gt;get_dof_map();
  dof_map.enforce_constraints_exactly(*_nonlinear_implicit_system,
                                      _nonlinear_implicit_system-&gt;solution.get());
  _nonlinear_implicit_system-&gt;update();

  _nl.setSolution(*_nonlinear_implicit_system-&gt;current_local_solution);

  _nonlinear_implicit_system-&gt;nonlinear_solver-&gt;converged = converged;
}

void
ActuallyExplicitEuler::postResidual(NumericVector&lt;Number&gt; &amp; residual)
{
  residual += _Re_time;
  residual += _Re_non_time;
  residual.close();

  // Reset time to the time at which to evaluate nodal BCs, which comes next
  _fe_problem.time() = _current_time;
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="b923bf70-aa15-4388-8741-2b77c800afa6"><div class="modal-content"><h4>(../../../SoftwareDownloads/moose/framework/src/timeintegrators/ActuallyExplicitEuler.C)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

// MOOSE includes
#include &quot;ActuallyExplicitEuler.h&quot;
#include &quot;NonlinearSystem.h&quot;
#include &quot;FEProblem.h&quot;

// libMesh includes
#include &quot;libmesh/nonlinear_solver.h&quot;

registerMooseObject(&quot;MooseApp&quot;, ActuallyExplicitEuler);

defineLegacyParams(ActuallyExplicitEuler);

InputParameters
ActuallyExplicitEuler::validParams()
{
  InputParameters params = ExplicitTimeIntegrator::validParams();

  params.addClassDescription(
      &quot;Implementation of Explicit/Forward Euler without invoking any of the nonlinear solver&quot;);

  params.addParam&lt;bool&gt;(&quot;use_constant_mass&quot;,
                        false,
                        &quot;If set to true, will only compute the mass matrix in the first time step, &quot;
                        &quot;and keep using it throughout the simulation.&quot;);

  return params;
}

ActuallyExplicitEuler::ActuallyExplicitEuler(const InputParameters &amp; parameters)
  : ExplicitTimeIntegrator(parameters), _constant_mass(getParam&lt;bool&gt;(&quot;use_constant_mass&quot;))
{
}

void
ActuallyExplicitEuler::computeTimeDerivatives()
{
  if (!_sys.solutionUDot())
    mooseError(&quot;ActuallyExplicitEuler: Time derivative of solution (`u_dot`) is not stored. Please &quot;
               &quot;set uDotRequested() to true in FEProblemBase before requesting `u_dot`.&quot;);

  NumericVector&lt;Number&gt; &amp; u_dot = *_sys.solutionUDot();
  u_dot = *_solution;
  computeTimeDerivativeHelper(u_dot, _solution_old);
  u_dot.close();

  _du_dot_du = 1.0 / _dt;
}

void
ActuallyExplicitEuler::computeADTimeDerivatives(DualReal &amp; ad_u_dot, const dof_id_type &amp; dof) const
{
  computeTimeDerivativeHelper(ad_u_dot, _solution_old(dof));
}

void
ActuallyExplicitEuler::solve()
{
  // Reset iteration counts
  _n_nonlinear_iterations = 0;
  _n_linear_iterations = 0;

  _current_time = _fe_problem.time();

  // Set time to the time at which to evaluate the residual
  _fe_problem.time() = _fe_problem.timeOld();
  _nonlinear_implicit_system-&gt;update();

  // Compute the residual
  _explicit_residual.zero();
  _fe_problem.computeResidual(*_nonlinear_implicit_system-&gt;current_local_solution,
                              _explicit_residual);

  // Move the residual to the RHS
  _explicit_residual *= -1.0;

  // Compute the mass matrix
  auto &amp; mass_matrix = _nonlinear_implicit_system-&gt;get_system_matrix();
  if (!_constant_mass || (_constant_mass &amp;&amp; _t_step == 1))
    _fe_problem.computeJacobianTag(
        *_nonlinear_implicit_system-&gt;current_local_solution, mass_matrix, _Ke_time_tag);

  // Perform the linear solve
  bool converged = performExplicitSolve(mass_matrix);

  // Update the solution
  *_nonlinear_implicit_system-&gt;solution = _nl.solutionOld();
  *_nonlinear_implicit_system-&gt;solution += _solution_update;

  // Enforce contraints on the solution
  DofMap &amp; dof_map = _nonlinear_implicit_system-&gt;get_dof_map();
  dof_map.enforce_constraints_exactly(*_nonlinear_implicit_system,
                                      _nonlinear_implicit_system-&gt;solution.get());
  _nonlinear_implicit_system-&gt;update();

  _nl.setSolution(*_nonlinear_implicit_system-&gt;current_local_solution);

  _nonlinear_implicit_system-&gt;nonlinear_solver-&gt;converged = converged;
}

void
ActuallyExplicitEuler::postResidual(NumericVector&lt;Number&gt; &amp; residual)
{
  residual += _Re_time;
  residual += _Re_non_time;
  residual.close();

  // Reset time to the time at which to evaluate nodal BCs, which comes next
  _fe_problem.time() = _current_time;
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="d38ec6df-dcb0-4ba0-a290-89944d627e10"><div class="modal-content"><h4>(../../../SoftwareDownloads/moose/framework/include/timeintegrators/LumpedPreconditioner.h)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

// MOOSE includes
#include &quot;NonlinearSystem.h&quot;
#include &quot;FEProblem.h&quot;
#include &quot;PetscSupport.h&quot;

// libMesh includes
#include &quot;libmesh/sparse_matrix.h&quot;
#include &quot;libmesh/nonlinear_solver.h&quot;
#include &quot;libmesh/preconditioner.h&quot;

// Forward declarations
class LumpedPreconditioner;

/**
 * Class to that applies the lumped mass matrix preconditioner
 * in the ExplicitTimeIntegrator
 */
class LumpedPreconditioner : public Preconditioner&lt;Real&gt;
{
public:
  LumpedPreconditioner(const NumericVector&lt;Real&gt; &amp; diag_inverse)
    : Preconditioner(diag_inverse.comm()), _diag_inverse(diag_inverse)
  {
  }

  virtual void init() override
  {
    // No more initialization needed here
    _is_initialized = true;
  }

  virtual void apply(const NumericVector&lt;Real&gt; &amp; x, NumericVector&lt;Real&gt; &amp; y) override
  {
    y.pointwise_mult(_diag_inverse, x);
  }

protected:
  /// The inverse of the diagonal of the lumped matrix
  const NumericVector&lt;Real&gt; &amp; _diag_inverse;
};
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="e899e051-d59b-4354-9ec0-7fd3a2fb977c"><div class="modal-content"><h4>(../../../SoftwareDownloads/moose/framework/src/timeintegrators/ExplicitTimeIntegrator.C)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

// MOOSE includes
#include &quot;ExplicitTimeIntegrator.h&quot;
#include &quot;NonlinearSystem.h&quot;
#include &quot;FEProblem.h&quot;
#include &quot;PetscSupport.h&quot;

// libMesh includes
#include &quot;libmesh/enum_convergence_flags.h&quot;

defineLegacyParams(ExplicitTimeIntegrator);

InputParameters
ExplicitTimeIntegrator::validParams()
{
  InputParameters params = TimeIntegrator::validParams();

  MooseEnum solve_type(&quot;consistent lumped lump_preconditioned&quot;, &quot;consistent&quot;);

  params.addParam&lt;MooseEnum&gt;(
      &quot;solve_type&quot;,
      solve_type,
      &quot;The way to solve the system.  A &#x27;consistent&#x27; solve uses the full mass matrix and actually &quot;
      &quot;needs to use a linear solver to solve the problem.  &#x27;lumped&#x27; uses a lumped mass matrix with &quot;
      &quot;a simple inversion - incredibly fast but may be less accurate.  &#x27;lump_preconditioned&#x27; uses &quot;
      &quot;the lumped mass matrix as a preconditioner for the &#x27;consistent&#x27; solve&quot;);

  return params;
}

ExplicitTimeIntegrator::ExplicitTimeIntegrator(const InputParameters &amp; parameters)
  : TimeIntegrator(parameters),
    MeshChangedInterface(parameters),

    _solve_type(getParam&lt;MooseEnum&gt;(&quot;solve_type&quot;)),
    _explicit_residual(_nl.addVector(&quot;explicit_residual&quot;, false, PARALLEL)),
    _solution_update(_nl.addVector(&quot;solution_update&quot;, true, PARALLEL)),
    _mass_matrix_diag(_nl.addVector(&quot;mass_matrix_diag&quot;, false, PARALLEL))
{
  _Ke_time_tag = _fe_problem.getMatrixTagID(&quot;TIME&quot;);

  // Try to keep MOOSE from doing any nonlinear stuff
  _fe_problem.solverParams()._type = Moose::ST_LINEAR;

  if (_solve_type == LUMPED || _solve_type == LUMP_PRECONDITIONED)
    _ones = &amp;_nl.addVector(&quot;ones&quot;, false, PARALLEL);
}

void
ExplicitTimeIntegrator::initialSetup()
{
  meshChanged();
}

void
ExplicitTimeIntegrator::init()
{
}

void
ExplicitTimeIntegrator::preSolve()
{
}

void
ExplicitTimeIntegrator::meshChanged()
{
  // Can only be done after the system is initialized
  if (_solve_type == LUMPED || _solve_type == LUMP_PRECONDITIONED)
    *_ones = 1.;

  if (_solve_type == CONSISTENT || _solve_type == LUMP_PRECONDITIONED)
    _linear_solver = LinearSolver&lt;Number&gt;::build(comm());

  if (_solve_type == LUMP_PRECONDITIONED)
  {
    _preconditioner = libmesh_make_unique&lt;LumpedPreconditioner&gt;(_mass_matrix_diag);
    _linear_solver-&gt;attach_preconditioner(_preconditioner.get());
    _linear_solver-&gt;init();
  }

  if (_solve_type == CONSISTENT || _solve_type == LUMP_PRECONDITIONED)
    Moose::PetscSupport::setLinearSolverDefaults(_fe_problem, *_linear_solver);
}

bool
ExplicitTimeIntegrator::performExplicitSolve(SparseMatrix&lt;Number&gt; &amp; mass_matrix)
{
  bool converged = false;

  switch (_solve_type)
  {
    case CONSISTENT:
    {
      converged = solveLinearSystem(mass_matrix);

      break;
    }
    case LUMPED:
    {
      // Computes the sum of each row (lumping)
      // Note: This is actually how PETSc does it
      // It&#x27;s not &quot;perfectly optimal&quot; - but it will be fast (and universal)
      mass_matrix.vector_mult(_mass_matrix_diag, *_ones);

      // &quot;Invert&quot; the diagonal mass matrix
      _mass_matrix_diag.reciprocal();

      // Multiply the inversion by the RHS
      _solution_update.pointwise_mult(_mass_matrix_diag, _explicit_residual);

      // Check for convergence by seeing if there is a nan or inf
      auto sum = _solution_update.sum();
      converged = std::isfinite(sum);

      // The linear iteration count remains zero
      _n_linear_iterations = 0;

      break;
    }
    case LUMP_PRECONDITIONED:
    {
      mass_matrix.vector_mult(_mass_matrix_diag, *_ones);
      _mass_matrix_diag.reciprocal();

      converged = solveLinearSystem(mass_matrix);

      break;
    }
    default:
      mooseError(&quot;Unknown solve_type in ExplicitTimeIntegrator.&quot;);
  }

  return converged;
}

bool
ExplicitTimeIntegrator::solveLinearSystem(SparseMatrix&lt;Number&gt; &amp; mass_matrix)
{
  auto &amp; es = _fe_problem.es();

  const auto num_its_and_final_tol =
      _linear_solver-&gt;solve(mass_matrix,
                            _solution_update,
                            _explicit_residual,
                            es.parameters.get&lt;Real&gt;(&quot;linear solver tolerance&quot;),
                            es.parameters.get&lt;unsigned int&gt;(&quot;linear solver maximum iterations&quot;));

  _n_linear_iterations += num_its_and_final_tol.first;

  const bool converged = checkLinearConvergence();

  return converged;
}

bool
ExplicitTimeIntegrator::checkLinearConvergence()
{
  auto reason = _linear_solver-&gt;get_converged_reason();

  switch (reason)
  {
    case CONVERGED_RTOL_NORMAL:
    case CONVERGED_ATOL_NORMAL:
    case CONVERGED_RTOL:
    case CONVERGED_ATOL:
    case CONVERGED_ITS:
    case CONVERGED_CG_NEG_CURVE:
    case CONVERGED_CG_CONSTRAINED:
    case CONVERGED_STEP_LENGTH:
    case CONVERGED_HAPPY_BREAKDOWN:
      return true;
    case DIVERGED_NULL:
    case DIVERGED_ITS:
    case DIVERGED_DTOL:
    case DIVERGED_BREAKDOWN:
    case DIVERGED_BREAKDOWN_BICG:
    case DIVERGED_NONSYMMETRIC:
    case DIVERGED_INDEFINITE_PC:
    case DIVERGED_NAN:
    case DIVERGED_INDEFINITE_MAT:
    case CONVERGED_ITERATING:
    case DIVERGED_PCSETUP_FAILED:
      return false;
    default:
      mooseError(&quot;Unknown convergence reason in ExplicitTimeIntegrator.&quot;);
  }
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="55c4fdb0-48ff-49d1-b91e-5020b4e49a72"><div class="modal-content"><h4>(../../../SoftwareDownloads/moose/framework/src/timeintegrators/ActuallyExplicitEuler.C)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

// MOOSE includes
#include &quot;ActuallyExplicitEuler.h&quot;
#include &quot;NonlinearSystem.h&quot;
#include &quot;FEProblem.h&quot;

// libMesh includes
#include &quot;libmesh/nonlinear_solver.h&quot;

registerMooseObject(&quot;MooseApp&quot;, ActuallyExplicitEuler);

defineLegacyParams(ActuallyExplicitEuler);

InputParameters
ActuallyExplicitEuler::validParams()
{
  InputParameters params = ExplicitTimeIntegrator::validParams();

  params.addClassDescription(
      &quot;Implementation of Explicit/Forward Euler without invoking any of the nonlinear solver&quot;);

  params.addParam&lt;bool&gt;(&quot;use_constant_mass&quot;,
                        false,
                        &quot;If set to true, will only compute the mass matrix in the first time step, &quot;
                        &quot;and keep using it throughout the simulation.&quot;);

  return params;
}

ActuallyExplicitEuler::ActuallyExplicitEuler(const InputParameters &amp; parameters)
  : ExplicitTimeIntegrator(parameters), _constant_mass(getParam&lt;bool&gt;(&quot;use_constant_mass&quot;))
{
}

void
ActuallyExplicitEuler::computeTimeDerivatives()
{
  if (!_sys.solutionUDot())
    mooseError(&quot;ActuallyExplicitEuler: Time derivative of solution (`u_dot`) is not stored. Please &quot;
               &quot;set uDotRequested() to true in FEProblemBase before requesting `u_dot`.&quot;);

  NumericVector&lt;Number&gt; &amp; u_dot = *_sys.solutionUDot();
  u_dot = *_solution;
  computeTimeDerivativeHelper(u_dot, _solution_old);
  u_dot.close();

  _du_dot_du = 1.0 / _dt;
}

void
ActuallyExplicitEuler::computeADTimeDerivatives(DualReal &amp; ad_u_dot, const dof_id_type &amp; dof) const
{
  computeTimeDerivativeHelper(ad_u_dot, _solution_old(dof));
}

void
ActuallyExplicitEuler::solve()
{
  // Reset iteration counts
  _n_nonlinear_iterations = 0;
  _n_linear_iterations = 0;

  _current_time = _fe_problem.time();

  // Set time to the time at which to evaluate the residual
  _fe_problem.time() = _fe_problem.timeOld();
  _nonlinear_implicit_system-&gt;update();

  // Compute the residual
  _explicit_residual.zero();
  _fe_problem.computeResidual(*_nonlinear_implicit_system-&gt;current_local_solution,
                              _explicit_residual);

  // Move the residual to the RHS
  _explicit_residual *= -1.0;

  // Compute the mass matrix
  auto &amp; mass_matrix = _nonlinear_implicit_system-&gt;get_system_matrix();
  if (!_constant_mass || (_constant_mass &amp;&amp; _t_step == 1))
    _fe_problem.computeJacobianTag(
        *_nonlinear_implicit_system-&gt;current_local_solution, mass_matrix, _Ke_time_tag);

  // Perform the linear solve
  bool converged = performExplicitSolve(mass_matrix);

  // Update the solution
  *_nonlinear_implicit_system-&gt;solution = _nl.solutionOld();
  *_nonlinear_implicit_system-&gt;solution += _solution_update;

  // Enforce contraints on the solution
  DofMap &amp; dof_map = _nonlinear_implicit_system-&gt;get_dof_map();
  dof_map.enforce_constraints_exactly(*_nonlinear_implicit_system,
                                      _nonlinear_implicit_system-&gt;solution.get());
  _nonlinear_implicit_system-&gt;update();

  _nl.setSolution(*_nonlinear_implicit_system-&gt;current_local_solution);

  _nonlinear_implicit_system-&gt;nonlinear_solver-&gt;converged = converged;
}

void
ActuallyExplicitEuler::postResidual(NumericVector&lt;Number&gt; &amp; residual)
{
  residual += _Re_time;
  residual += _Re_non_time;
  residual.close();

  // Reset time to the time at which to evaluate nodal BCs, which comes next
  _fe_problem.time() = _current_time;
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="ed867f14-2b43-429a-b418-d6fdc38c0b47"><div class="modal-content"><h4>(../../../SoftwareDownloads/moose/framework/src/timeintegrators/ActuallyExplicitEuler.C)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

// MOOSE includes
#include &quot;ActuallyExplicitEuler.h&quot;
#include &quot;NonlinearSystem.h&quot;
#include &quot;FEProblem.h&quot;

// libMesh includes
#include &quot;libmesh/nonlinear_solver.h&quot;

registerMooseObject(&quot;MooseApp&quot;, ActuallyExplicitEuler);

defineLegacyParams(ActuallyExplicitEuler);

InputParameters
ActuallyExplicitEuler::validParams()
{
  InputParameters params = ExplicitTimeIntegrator::validParams();

  params.addClassDescription(
      &quot;Implementation of Explicit/Forward Euler without invoking any of the nonlinear solver&quot;);

  params.addParam&lt;bool&gt;(&quot;use_constant_mass&quot;,
                        false,
                        &quot;If set to true, will only compute the mass matrix in the first time step, &quot;
                        &quot;and keep using it throughout the simulation.&quot;);

  return params;
}

ActuallyExplicitEuler::ActuallyExplicitEuler(const InputParameters &amp; parameters)
  : ExplicitTimeIntegrator(parameters), _constant_mass(getParam&lt;bool&gt;(&quot;use_constant_mass&quot;))
{
}

void
ActuallyExplicitEuler::computeTimeDerivatives()
{
  if (!_sys.solutionUDot())
    mooseError(&quot;ActuallyExplicitEuler: Time derivative of solution (`u_dot`) is not stored. Please &quot;
               &quot;set uDotRequested() to true in FEProblemBase before requesting `u_dot`.&quot;);

  NumericVector&lt;Number&gt; &amp; u_dot = *_sys.solutionUDot();
  u_dot = *_solution;
  computeTimeDerivativeHelper(u_dot, _solution_old);
  u_dot.close();

  _du_dot_du = 1.0 / _dt;
}

void
ActuallyExplicitEuler::computeADTimeDerivatives(DualReal &amp; ad_u_dot, const dof_id_type &amp; dof) const
{
  computeTimeDerivativeHelper(ad_u_dot, _solution_old(dof));
}

void
ActuallyExplicitEuler::solve()
{
  // Reset iteration counts
  _n_nonlinear_iterations = 0;
  _n_linear_iterations = 0;

  _current_time = _fe_problem.time();

  // Set time to the time at which to evaluate the residual
  _fe_problem.time() = _fe_problem.timeOld();
  _nonlinear_implicit_system-&gt;update();

  // Compute the residual
  _explicit_residual.zero();
  _fe_problem.computeResidual(*_nonlinear_implicit_system-&gt;current_local_solution,
                              _explicit_residual);

  // Move the residual to the RHS
  _explicit_residual *= -1.0;

  // Compute the mass matrix
  auto &amp; mass_matrix = _nonlinear_implicit_system-&gt;get_system_matrix();
  if (!_constant_mass || (_constant_mass &amp;&amp; _t_step == 1))
    _fe_problem.computeJacobianTag(
        *_nonlinear_implicit_system-&gt;current_local_solution, mass_matrix, _Ke_time_tag);

  // Perform the linear solve
  bool converged = performExplicitSolve(mass_matrix);

  // Update the solution
  *_nonlinear_implicit_system-&gt;solution = _nl.solutionOld();
  *_nonlinear_implicit_system-&gt;solution += _solution_update;

  // Enforce contraints on the solution
  DofMap &amp; dof_map = _nonlinear_implicit_system-&gt;get_dof_map();
  dof_map.enforce_constraints_exactly(*_nonlinear_implicit_system,
                                      _nonlinear_implicit_system-&gt;solution.get());
  _nonlinear_implicit_system-&gt;update();

  _nl.setSolution(*_nonlinear_implicit_system-&gt;current_local_solution);

  _nonlinear_implicit_system-&gt;nonlinear_solver-&gt;converged = converged;
}

void
ActuallyExplicitEuler::postResidual(NumericVector&lt;Number&gt; &amp; residual)
{
  residual += _Re_time;
  residual += _Re_non_time;
  residual.close();

  // Reset time to the time at which to evaluate nodal BCs, which comes next
  _fe_problem.time() = _current_time;
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></div><div class="col hide-on-med-and-down l2"><div class="toc-wrapper pin-top"><ul class="section table-of-contents"><li><a href="#bd11576a-6ab3-4c7f-870b-77184c06ab9d" class="tooltipped" data-position="left" data-tooltip="Description">Description</a></li><li><a href="#87c8d255-602f-4ecf-9e72-ee55bc2ccca9" class="tooltipped" data-position="left" data-tooltip="Methods of Solution">Methods of Solution</a></li><li><a href="#f5e108d9-2ae2-4fd8-96d2-d35c86c1bdf7" class="tooltipped" data-position="left" data-tooltip="Additional Details">Additional Details</a></li></ul></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="../../contrib/fuse/fuse.min.js"></script><script type="text/javascript" src="../../js/search_index.js"></script>